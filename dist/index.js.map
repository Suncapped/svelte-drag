{
  "version": 3,
  "sources": ["../src/memoize.js", "../src/index.ts"],
  "sourcesContent": ["//\n// Code from `fast-memoize`\n//\n\nfunction memoize(fn, options) {\n  var cache = options && options.cache ? options.cache : cacheDefault;\n\n  var serializer = options && options.serializer ? options.serializer : serializerDefault;\n\n  var strategy = options && options.strategy ? options.strategy : strategyDefault;\n\n  return strategy(fn, {\n    cache: cache,\n    serializer: serializer,\n  });\n}\n\n//\n// Strategy\n//\n\nfunction isPrimitive(value) {\n  return value == null || typeof value === 'number' || typeof value === 'boolean'; // || typeof value === \"string\" 'unsafe' primitive for our needs\n}\n\nfunction monadic(fn, cache, serializer, arg) {\n  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);\n\n  var computedValue = cache.get(cacheKey);\n  if (typeof computedValue === 'undefined') {\n    computedValue = fn.call(this, arg);\n    cache.set(cacheKey, computedValue);\n  }\n\n  return computedValue;\n}\n\nfunction variadic(fn, cache, serializer) {\n  var args = Array.prototype.slice.call(arguments, 3);\n  var cacheKey = serializer(args);\n\n  var computedValue = cache.get(cacheKey);\n  if (typeof computedValue === 'undefined') {\n    computedValue = fn.apply(this, args);\n    cache.set(cacheKey, computedValue);\n  }\n\n  return computedValue;\n}\n\nfunction assemble(fn, context, strategy, cache, serialize) {\n  return strategy.bind(context, fn, cache, serialize);\n}\n\nfunction strategyDefault(fn, options) {\n  var strategy = fn.length === 1 ? monadic : variadic;\n\n  return assemble(fn, this, strategy, options.cache.create(), options.serializer);\n}\n\nfunction strategyVariadic(fn, options) {\n  var strategy = variadic;\n\n  return assemble(fn, this, strategy, options.cache.create(), options.serializer);\n}\n\nfunction strategyMonadic(fn, options) {\n  var strategy = monadic;\n\n  return assemble(fn, this, strategy, options.cache.create(), options.serializer);\n}\n\n//\n// Serializer\n//\n\nfunction serializerDefault() {\n  return JSON.stringify(arguments);\n}\n\n//\n// Cache\n//\n\nfunction ObjectWithoutPrototypeCache() {\n  this.cache = Object.create(null);\n}\n\nObjectWithoutPrototypeCache.prototype.has = function (key) {\n  return key in this.cache;\n};\n\nObjectWithoutPrototypeCache.prototype.get = function (key) {\n  return this.cache[key];\n};\n\nObjectWithoutPrototypeCache.prototype.set = function (key, value) {\n  this.cache[key] = value;\n};\n\nvar cacheDefault = {\n  create: function create() {\n    return new ObjectWithoutPrototypeCache();\n  },\n};\n\n//\n// API\n//\n\nexport default memoize;\nexport const strategies = {\n  variadic: strategyVariadic,\n  monadic: strategyMonadic,\n};\n", "import memoize from './memoize';\n\nexport type DragBoundsCoords = {\n  /** Number of pixels from left of the document */\n  left: number;\n\n  /** Number of pixels from top of the document */\n  top: number;\n\n  /** Number of pixels from the right side of document */\n  right: number;\n\n  /** Number of pixels from the bottom of the document */\n  bottom: number;\n};\n\nexport type DragAxis = 'both' | 'x' | 'y' | 'none';\n\nexport type DragBounds = 'parent' | Partial<DragBoundsCoords> | string;\n\nexport type DragOptions = {\n  /**\n   * Optionally limit the drag area\n   *\n   * Accepts `parent` as prefixed value, and limits it to its parent.\n   *\n   * Or, you can specify any selector and it will be bound to that.\n   *\n   * **Note**: We don't check whether the selector is bigger than the node element.\n   * You yourself will have to make sure of that, or it may lead to strange behavior\n   *\n   * Or, finally, you can pass an object of type `{ top: number; right: number; bottom: number; left: number }`.\n   * These mimic the css `top`, `right`, `bottom` and `left`, in the sense that `bottom` starts from the bottom of the window, and `right` from right of window.\n   * If any of these properties are unspecified, they are assumed to be `0`.\n   *\n   * @example\n   * ```svelte\n   * <!-- Bound to parent element -->\n   * <div use:draggable={{ bounds: 'parent' }}>\n   *   Hello\n   * </div>\n   * ```\n   *\n   * @example\n   * ```svelte\n   * <!-- Bound to body -->\n   * <div use:draggable={{ bounds: 'body' }}>\n   *   Hello\n   * </div>\n   * ```\n   *\n   * @example\n   * ```svelte\n   * <!-- Bound to arbitrary coordinates -->\n   * <div use:draggable={{ bounds: { top: 100, right: 100, bottom: 100, left: 100 } }}>\n   *   Hello\n   * </div>\n   * ```\n   */\n  bounds?: DragBounds;\n\n  /**\n   * Axis on which the element can be dragged on. Valid values: `both`, `x`, `y`, `none`.\n   *\n   * - `both` - Element can move in any direction\n   * - `x` - Only horizontal movement possible\n   * - `y` - Only vertical movement possible\n   * - `none` - No movement at all\n   *\n   * @default 'both'\n   *\n   * @example\n   * ```svelte\n   * <!-- Drag only in x direction -->\n   * <div use:draggable={{ axis: 'x' }}>\n   *   Text\n   * </div>\n   * ```\n   */\n  axis?: DragAxis;\n\n  /**\n   * If true, uses `translate3d` instead of `translate` to move the element around, and the hardware acceleration kicks in.\n   *\n   * `true` by default, but can be set to `false` if [blurry text issue](https://developpaper.com/question/why-does-the-use-of-css3-translate3d-result-in-blurred-display/) occur\n   *\n   * @default true\n   *\n   * @example\n   * ```svelte\n   * <!-- Disable GPU acceleration -->\n   * <div use:draggable={{ gpuAcceleration: false }}>\n   *   Text\n   * </div>\n   * ```\n   */\n  gpuAcceleration?: boolean;\n\n  /**\n   * Applies `user-select: none` on `<body />` element when dragging,\n   * to prevent the irritating effect where dragging doesn't happen and the text is selected.\n   * Applied when dragging starts and removed when it stops.\n   *\n   * Can be disabled using this option\n   *\n   * @default true\n   *\n   * @example\n   * ```svelte\n   * <!-- Do not disable user selection -->\n   * <div use:draggable={{ applyUserSelectHack: false }}>\n   *   Text\n   * </div>\n   * ```\n   */\n  applyUserSelectHack?: boolean;\n\n  /**\n   * Disables dragging altogether.\n   *\n   * @default false\n   *\n   * @example\n   * ```svelte\n   * <!-- Disable it entirely -->\n   * <div use:draggable={{ disabled: true }}>\n   *   Text\n   * </div>\n   * ```\n   */\n  disabled?: boolean;\n\n  /**\n   * Applies a grid on the page to which the element snaps to when dragging, rather than the default continuous grid.\n   *\n   * `Note`: If you're programmatically creating the grid, do not set it to [0, 0] ever, that will stop drag at all. Set it to `undefined`.\n   *\n   * @default undefined\n   *\n   * @example\n   * ```svelte\n   * <!-- Snap to a grid of 10 by 10 -->\n   * <div use:draggable={{ grid: [10, 10] }}>\n   *   Text\n   * </div>\n   * ```\n   */\n  grid?: [number, number];\n\n  /**\n   * CSS Selector of an element inside the parent node(on which `use:draggable` is applied).\n   *\n   * If it is provided, Trying to drag inside the `cancel` selector will prevent dragging.\n   *\n   * @default undefined\n   *\n   * @example\n   * <!-- Grid has a cancel element -->\n   * <div use:draggable={{ cancel: '.cancel' }}>\n   *   Text\n   *   <div class=\"cancel\">This won't drag</div>\n   * </div>\n   * ```\n   */\n  cancel?: string;\n\n  /**\n   * CSS Selector of an element inside the parent node(on which `use:draggable` is applied).\n   *\n   * If it is provided, Only clicking and dragging on this element will allow the parent to drag, anywhere else on the parent won't work.\n   *\n   * @default undefined\n   *\n   * @example\n   * <!-- Grid has a handle element -->\n   * <div use:draggable={{ handle: '.handel' }}>\n   *   This won't drag\n   *   <div class=\"handel\">This sure will drag!!</div>\n   * </div>\n   * ```\n   */\n  handle?: string;\n\n  /**\n   * Class to apply on the element on which `use:draggable` is applied.\n   * Note that if `handle` is provided, it will still apply class on the parent element, **NOT** the handle\n   *\n   * @default 'svelte-draggable'\n   */\n  defaultClass?: string;\n\n  /**\n   * Class to apply on the parent element when it is dragging\n   *\n   * @default 'svelte-draggable-dragging'\n   */\n  defaultClassDragging?: string;\n\n  /**\n   * Class to apply on the parent element if it has been dragged at least once.\n   *\n   * @default 'svelte-draggable-dragged'\n   */\n  defaultClassDragged?: string;\n\n  /**\n   * Offsets your element to the position you specify in the very beginning.\n   * `x` and `y` should be in pixels\n   *\n   \n   *\n   * @example\n   * <!-- Place the element at (300, 200) at the very beginning -->\n   * <div use:draggable={{ defaultPosition: { x: 300; y: 200 } }}>\n   *   Hello\n   * </div>\n   * ```\n   */\n  defaultPosition?: { x: number; y: number };\n};\n\nconst DEFAULT_CLASS = {\n  MAIN: 'svelte-draggable',\n  DRAGGING: 'svelte-draggable-dragging',\n  DRAGGED: 'svelte-draggable-dragged',\n};\n\nexport const draggable = (node: HTMLElement, options: DragOptions = {}) => {\n  let {\n    bounds,\n    axis = 'both',\n    gpuAcceleration = true,\n    applyUserSelectHack = true,\n    disabled = false,\n\n    grid,\n\n    cancel,\n    handle,\n\n    defaultClass = DEFAULT_CLASS.MAIN,\n    defaultClassDragging = DEFAULT_CLASS.DRAGGING,\n    defaultClassDragged = DEFAULT_CLASS.DRAGGED,\n\n    defaultPosition = { x: 0, y: 0 },\n  } = options;\n\n  let active = false;\n\n  let [translateX, translateY] = [0, 0];\n  let [initialX, initialY] = [0, 0];\n  let [previousX, previousY] = [0, 0];\n\n  // The offset of the client position relative to the node's top-left corner\n  let [clientToNodeOffsetX, clientToNodeOffsetY] = [0, 0];\n\n  let [xOffset, yOffset] = [defaultPosition.x, defaultPosition.y];\n\n  setTranslate(xOffset, yOffset, node, gpuAcceleration);\n\n  let canMoveInX: boolean;\n  let canMoveInY: boolean;\n\n  let bodyOriginalUserSelectVal = '';\n\n  let computedBounds: DragBoundsCoords;\n  let nodeRect: DOMRect;\n\n  let dragEl: HTMLElement | undefined;\n  let cancelEl: HTMLElement | undefined;\n\n  function fireSvelteDragStopEvent(node: HTMLElement) {\n    node.dispatchEvent(\n      new CustomEvent('svelte-drag:end', { detail: { offsetX: translateX, offsetY: translateY } })\n    );\n  }\n\n  function fireSvelteDragStartEvent(node: HTMLElement) {\n    node.dispatchEvent(\n      new CustomEvent('svelte-drag:start', { detail: { offsetX: translateX, offsetY: translateY } })\n    );\n  }\n\n  function fireSvelteDragEvent(node: HTMLElement, translateX: number, translateY: number) {\n    node.dispatchEvent(\n      new CustomEvent('svelte-drag', { detail: { offsetX: translateX, offsetY: translateY } })\n    );\n  }\n\n  const listen = addEventListener;\n\n  listen('touchstart', dragStart, false);\n  listen('touchend', dragEnd, false);\n  listen('touchmove', drag, false);\n\n  listen('mousedown', dragStart, false);\n  listen('mouseup', dragEnd, false);\n  listen('mousemove', drag, false);\n\n  // On mobile, touch can become extremely janky without it\n  node.style.touchAction = 'none';\n\n  function dragStart(e: TouchEvent | MouseEvent) {\n    if (disabled) return;\n\n    node.classList.add(defaultClass);\n\n    dragEl = getDragEl(handle, node);\n    cancelEl = getCancelElement(cancel, node);\n\n    canMoveInX = ['both', 'x'].includes(axis);\n    canMoveInY = ['both', 'y'].includes(axis);\n\n    // Compute bounds\n    if (typeof bounds !== 'undefined') computedBounds = computeBoundRect(bounds, node);\n\n    // Compute current node's bounding client Rectangle\n    nodeRect = node.getBoundingClientRect();\n\n    if (isString(handle) && isString(cancel) && handle === cancel)\n      throw new Error(\"`handle` selector can't be same as `cancel` selector\");\n\n    if (cancelEl?.contains(dragEl))\n      throw new Error(\n        \"Element being dragged can't be a child of the element on which `cancel` is applied\"\n      );\n\n    if (dragEl.contains(e.target as HTMLElement) && !cancelEl?.contains(e.target as HTMLElement))\n      active = true;\n\n    if (!active) return;\n\n    if (applyUserSelectHack) {\n      // Apply user-select: none on body to prevent misbehavior\n      bodyOriginalUserSelectVal = document.body.style.userSelect;\n      document.body.style.userSelect = 'none';\n    }\n    // Dispatch custom event\n    fireSvelteDragStartEvent(node);\n\n    const { clientX, clientY } = isTouchEvent(e) ? e.touches[0] : e;\n\n    if (canMoveInX) initialX = clientX - xOffset;\n    if (canMoveInY) initialY = clientY - yOffset;\n\n    // Only the bounds uses these properties at the moment,\n    // may open up in the future if others need it\n    if (computedBounds) {\n      clientToNodeOffsetX = clientX - nodeRect.left;\n      clientToNodeOffsetY = clientY - nodeRect.top;\n    }\n  }\n\n  function dragEnd(e: MouseEvent | TouchEvent) {\n    if (disabled) return;\n    if (!active) return;\n\n    // required, or the event will be fired for every single draggable instance present\n    if (!node.contains(e.target as HTMLElement)) return;\n\n    // Apply class defaultClassDragged\n    node.classList.remove(defaultClassDragging);\n    node.classList.add(defaultClassDragged);\n\n    if (applyUserSelectHack) document.body.style.userSelect = bodyOriginalUserSelectVal;\n\n    fireSvelteDragStopEvent(node);\n\n    if (canMoveInX) initialX = translateX;\n    if (canMoveInX) initialY = translateY;\n\n    active = false;\n  }\n\n  function drag(e: TouchEvent | MouseEvent) {\n    if (disabled) return;\n\n    if (!active) return;\n\n    // Apply class defaultClassDragging\n    node.classList.add(defaultClassDragging);\n\n    e.preventDefault();\n\n    nodeRect = node.getBoundingClientRect();\n\n    const { clientX, clientY } = isTouchEvent(e) ? e.touches[0] : e;\n\n    // Get final values for clamping\n    let [finalX, finalY] = [clientX, clientY];\n\n    if (computedBounds) {\n      // Client position is limited to this virtual boundary to prevent node going out of bounds\n      const virtualClientBounds: DragBoundsCoords = {\n        left: computedBounds.left + clientToNodeOffsetX,\n        top: computedBounds.top + clientToNodeOffsetY,\n        right: computedBounds.right + clientToNodeOffsetX - nodeRect.width,\n        bottom: computedBounds.bottom + clientToNodeOffsetY - nodeRect.height,\n      };\n\n      finalX = Math.min(Math.max(finalX, virtualClientBounds.left), virtualClientBounds.right);\n      finalY = Math.min(Math.max(finalY, virtualClientBounds.top), virtualClientBounds.bottom);\n    }\n\n    if (Array.isArray(grid)) {\n      let [xSnap, ySnap] = grid;\n\n      if (isNaN(+xSnap) || xSnap < 0)\n        throw new Error('1st argument of `grid` must be a valid positive number');\n\n      if (isNaN(+ySnap) || ySnap < 0)\n        throw new Error('2nd argument of `grid` must be a valid positive number');\n\n      let [deltaX, deltaY] = [finalX - previousX, finalY - previousY];\n      [deltaX, deltaY] = snapToGrid([xSnap, ySnap], deltaX, deltaY);\n\n      if (!deltaX && !deltaY) return;\n\n      [finalX, finalY] = [previousX + deltaX, previousY + deltaY];\n    }\n\n    if (canMoveInX) translateX = finalX - initialX;\n    if (canMoveInY) translateY = finalY - initialY;\n\n    [xOffset, yOffset] = [translateX, translateY];\n\n    fireSvelteDragEvent(node, translateX, translateY);\n\n    Promise.resolve().then(() => setTranslate(translateX, translateY, node, gpuAcceleration));\n  }\n\n  return {\n    destroy: () => {\n      const unlisten = removeEventListener;\n\n      unlisten('touchstart', dragStart, false);\n      unlisten('touchend', dragEnd, false);\n      unlisten('touchmove', drag, false);\n\n      unlisten('mousedown', dragStart, false);\n      unlisten('mouseup', dragEnd, false);\n      unlisten('mousemove', drag, false);\n    },\n    update: (options: DragOptions) => {\n      // Update all the values that need to be changed\n      axis = options.axis || 'both';\n      disabled = options.disabled ?? false;\n      handle = options.handle;\n      bounds = options.bounds;\n      cancel = options.cancel;\n      applyUserSelectHack = options.applyUserSelectHack ?? true;\n      grid = options.grid;\n      gpuAcceleration = options.gpuAcceleration ?? true;\n\n      const dragged = node.classList.contains(defaultClassDragged);\n\n      node.classList.remove(defaultClass, defaultClassDragged);\n\n      defaultClass = options.defaultClass ?? DEFAULT_CLASS.MAIN;\n      defaultClassDragging = options.defaultClassDragging ?? DEFAULT_CLASS.DRAGGING;\n      defaultClassDragged = options.defaultClassDragged ?? DEFAULT_CLASS.DRAGGED;\n\n      node.classList.add(defaultClass);\n\n      if (dragged) node.classList.add(defaultClassDragged);\n    },\n  };\n};\n\nfunction isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return Boolean((event as TouchEvent).touches && (event as TouchEvent).touches.length);\n}\n\nfunction isString(val: unknown): val is string {\n  return typeof val === 'string';\n}\n\nconst snapToGrid = memoize(\n  ([xSnap, ySnap]: [number, number], pendingX: number, pendingY: number): [number, number] => {\n    const x = Math.round(pendingX / xSnap) * xSnap;\n    const y = Math.round(pendingY / ySnap) * ySnap;\n    return [x, y];\n  }\n);\n\nfunction getDragEl(handle: string | undefined, node: HTMLElement) {\n  if (!handle) return node;\n\n  // Valid!! Let's check if this selector exists or not\n  const handleEl = node.querySelector<HTMLElement>(handle);\n  if (handleEl === null)\n    throw new Error(\n      'Selector passed for `handle` option should be child of the element on which the action is applied'\n    );\n\n  return handleEl!;\n}\n\nfunction getCancelElement(cancel: string | undefined, node: HTMLElement) {\n  if (!cancel) return;\n\n  const cancelEl = node.querySelector<HTMLElement>(cancel);\n\n  if (cancelEl === null)\n    throw new Error(\n      'Selector passed for `cancel` option should be child of the element on which the action is applied'\n    );\n\n  return cancelEl;\n}\n\nfunction computeBoundRect(bounds: string | Partial<DragBoundsCoords>, rootNode: HTMLElement) {\n  if (typeof bounds === 'object') {\n    // we have the left right etc\n    const [windowWidth, windowHeight] = [window.innerWidth, window.innerHeight];\n\n    const { top = 0, left = 0, right = 0, bottom = 0 } = bounds;\n\n    const computedRight = windowWidth - right;\n    const computedBottom = windowHeight - bottom;\n\n    return { top, right: computedRight, bottom: computedBottom, left };\n  }\n\n  // It's a string\n  if (bounds === 'parent') return (rootNode.parentNode as HTMLElement).getBoundingClientRect();\n\n  const node = document.querySelector<HTMLElement>(bounds);\n\n  if (node === null)\n    throw new Error(\"The selector provided for bound doesn't exists in the document.\");\n\n  const computedBounds = node!.getBoundingClientRect();\n\n  return computedBounds;\n}\n\nfunction setTranslate(xPos: number, yPos: number, el: HTMLElement, gpuAcceleration: boolean) {\n  el.style.transform = gpuAcceleration\n    ? `translate3d(${+xPos}px, ${+yPos}px, 0)`\n    : `translate(${+xPos}px, ${+yPos}px)`;\n}\n"],
  "mappings": "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",
  "names": []
}
